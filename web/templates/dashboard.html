<!DOCTYPE html>
<html>
  <head>
    <title>Snake AI Training Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #2c3e50;
        color: #ecf0f1;
        overflow-x: hidden;
      }
      .dashboard {
        display: grid;
        grid-template-columns: 1fr 350px;
        grid-template-rows: auto 1fr;
        grid-template-areas:
          "game-view stats"
          "charts controls";
        gap: 15px;
        padding: 15px;
        height: 100vh;
        box-sizing: border-box;
      }
      .panel {
        background-color: #34495e;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      .game-panel {
        grid-area: game-view;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .stats-panel {
        grid-area: stats;
        overflow-y: auto;
        max-height: calc(100vh - 30px);
      }
      .chart-panel {
        grid-area: charts;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .control-panel {
        grid-area: controls;
      }
      .stat-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .stat-item {
        margin-bottom: 5px;
      }
      .stat-value {
        font-size: 18px;
        font-weight: bold;
        color: #2ecc71;
      }
      .stat-label {
        color: #95a5a6;
        font-size: 12px;
        display: block;
      }
      .section-title {
        font-size: 16px;
        margin-top: 15px;
        margin-bottom: 10px;
        color: #3498db;
        border-bottom: 1px solid #3498db;
        padding-bottom: 5px;
      }
      #game-canvas {
        background-color: #2c3e50;
        border-radius: 4px;
        width: 50%; /* Reduce to 50% width */
        height: auto;
        aspect-ratio: 4/3; /* Maintain the 4:3 aspect ratio to match the grid dimensions */
        margin: 0 auto; /* Center the canvas */
        display: block; /* Ensure proper margin centering */
      }
      .reset-button {
        background-color: #e74c3c;
        color: #ecf0f1;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        width: 100%;
        transition: background-color 0.3s;
      }
      .reset-button:hover {
        background-color: #c0392b;
      }
      .chart-container {
        width: 100%;
        height: 250px;
      }
      .failure-stats {
        margin-top: 10px;
      }
      .failure-reason {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
      }
      .progress-bar {
        height: 8px;
        background-color: #2c3e50;
        border-radius: 4px;
        margin-top: 2px;
      }
      .progress-fill {
        height: 100%;
        border-radius: 4px;
      }
      .wall-collision {
        background-color: #e74c3c;
      }
      .self-collision {
        background-color: #f39c12;
      }
      .timeout {
        background-color: #3498db;
      }
    </style>
  </head>
  <body>
    <div class="dashboard">
      <div class="panel game-panel">
        <h2>Game View</h2>
        <canvas id="game-canvas"></canvas>
      </div>

      <div class="panel stats-panel">
        <h2>Training Statistics</h2>

        <div class="section-title">Current Session</div>
        <div class="stat-grid">
          <div class="stat-item">
            <span class="stat-label">Current Score</span>
            <span id="current-score" class="stat-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Episodes</span>
            <span id="episodes" class="stat-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Average Score</span>
            <span id="avg-score" class="stat-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Max Score</span>
            <span id="max-score" class="stat-value">0</span>
          </div>
        </div>

        <div class="section-title">Performance</div>
        <div class="stat-grid">
          <div class="stat-item">
            <span class="stat-label">Success Rate</span>
            <span id="success-rate" class="stat-value">0%</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Avg Reward</span>
            <span id="avg-reward" class="stat-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Avg Steps/Apple</span>
            <span id="steps-per-apple" class="stat-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Moving Avg (20)</span>
            <span id="moving-avg" class="stat-value">0</span>
          </div>
        </div>

        <div class="section-title">Learning Parameters</div>
        <div class="stat-grid">
          <div class="stat-item">
            <span class="stat-label">Exploration Rate (ε)</span>
            <span id="epsilon" class="stat-value">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Learning Rate (α)</span>
            <span id="learning-rate" class="stat-value">0</span>
          </div>
        </div>

        <div class="section-title">Failure Analysis</div>
        <div class="failure-stats">
          <div class="failure-reason">
            <span>Wall Collisions:</span>
            <span id="wall-collisions">0</span>
          </div>
          <div class="progress-bar">
            <div id="wall-failure-bar" class="progress-fill wall-collision" style="width: 0%"></div>
          </div>

          <div class="failure-reason">
            <span>Self Collisions:</span>
            <span id="self-collisions">0</span>
          </div>
          <div class="progress-bar">
            <div id="self-failure-bar" class="progress-fill self-collision" style="width: 0%"></div>
          </div>

          <div class="failure-reason">
            <span>Timeouts:</span>
            <span id="timeouts">0</span>
          </div>
          <div class="progress-bar">
            <div id="timeout-failure-bar" class="progress-fill timeout" style="width: 0%"></div>
          </div>

          <div class="section-title">Self Collision Analysis</div>
          <div class="stat-grid">
            <div class="stat-item">
              <span class="stat-label">Self Collision %</span>
              <span id="self-collision-percent" class="stat-value">0%</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Recent Rate (last 100)</span>
              <span id="recent-self-collision-rate" class="stat-value">0%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="panel chart-panel">
        <div class="chart-container" id="score-chart"></div>
        <div class="chart-container" id="reward-chart"></div>
        <div class="chart-container" id="learning-rate-chart"></div>
        <div class="chart-container" id="failure-reasons-chart"></div>
      </div>

      <div class="panel control-panel">
        <h2>Training Controls</h2>
        <button id="reset-training" class="reset-button">Reset Training</button>
        <div class="section-title">Session Info</div>
        <div class="stat-item">
          <span class="stat-label">Training Duration</span>
          <span id="training-duration" class="stat-value">00:00:00</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Episodes per Minute</span>
          <span id="episodes-per-minute" class="stat-value">0</span>
        </div>
      </div>
    </div>

    <script>
      const socket = io()
      let scores = []
      let episodes = []
      let rewards = []
      let learningRates = []
      let startTime = new Date()
      let failureStats = {
        wallCollision: 0,
        selfCollision: 0,
        timeout: 0,
        total: 0,
      }

      // Arrays to track failure reasons over time
      let wallCollisionHistory = []
      let selfCollisionHistory = []
      let timeoutHistory = []
      let episodesForFailures = []

      // Canvas setup
      const canvas = document.getElementById("game-canvas")
      const ctx = canvas.getContext("2d")

      // Grid dimensions from the game constants
      const GRID_WIDTH = 40 // WINDOW_WIDTH (800) / GRID_SIZE (20)
      const GRID_HEIGHT = 30 // WINDOW_HEIGHT (600) / GRID_SIZE (20)
      const GRID_SIZE = 20

      // Game state variables
      let lastGameState = null
      let wallCollisionCount = 0 // Track wall collisions

      // Set canvas dimensions to match the grid
      function resizeCanvas() {
        // Calculate container width (50% of parent width)
        const parentWidth = canvas.parentElement.clientWidth
        const containerWidth = Math.min(parentWidth * 0.5, 400) // 50% of parent width, max 400px

        // Add extra space for walls (2 cells in width, 2 cells in height)
        canvas.width = containerWidth
        canvas.height = (containerWidth / GRID_WIDTH) * GRID_HEIGHT
      }

      // Initial resize
      resizeCanvas()

      // Initialize empty charts on page load
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize wall collision counter with existing failure stats
        document.getElementById("wall-collisions").textContent = failureStats.wallCollision || "0"

        // Create empty traces for initial charts
        const emptyTrace = {
          x: [],
          y: [],
          type: "scatter",
          mode: "lines",
        }

        const scoreLayout = {
          title: "Training Progress",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: { title: "Score", gridcolor: "#455565" },
        }

        const rewardLayout = {
          title: "Average Reward",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: { title: "Reward", gridcolor: "#455565" },
        }

        const learningRateLayout = {
          title: "Learning Rate Adaptation",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: {
            title: "Learning Rate",
            gridcolor: "#455565",
            type: "log",
          },
        }

        const failureReasonsLayout = {
          title: "Failure Reasons Over Time",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: {
            title: "Percentage",
            gridcolor: "#455565",
            tickformat: ".0%",
            range: [0, 100],
          },
          legend: {
            orientation: "h",
            y: -0.2,
          },
        }

        // Initialize all charts with empty data
        Plotly.newPlot("score-chart", [emptyTrace], scoreLayout)
        Plotly.newPlot("reward-chart", [emptyTrace], rewardLayout)
        Plotly.newPlot("learning-rate-chart", [emptyTrace], learningRateLayout)
        Plotly.newPlot("failure-reasons-chart", [emptyTrace], failureReasonsLayout)
      })

      // Add reset button event listener
      document.getElementById("reset-training").addEventListener("click", function () {
        if (
          confirm(
            "Are you sure you want to reset the training? This will delete all current progress."
          )
        ) {
          socket.emit("reset_training")
          startTime = new Date() // Reset timer
          failureStats = { wallCollision: 0, selfCollision: 0, timeout: 0, total: 0 }
          wallCollisionCount = 0
          document.getElementById("wall-collisions").textContent = "0"
        }
      })

      // Update training duration
      setInterval(function () {
        const now = new Date()
        const diff = Math.floor((now - startTime) / 1000)
        const hours = Math.floor(diff / 3600)
          .toString()
          .padStart(2, "0")
        const minutes = Math.floor((diff % 3600) / 60)
          .toString()
          .padStart(2, "0")
        const seconds = Math.floor(diff % 60)
          .toString()
          .padStart(2, "0")
        document.getElementById("training-duration").textContent = `${hours}:${minutes}:${seconds}`

        // Calculate episodes per minute
        if (diff > 0) {
          const episodesCount = parseInt(document.getElementById("episodes").textContent) || 0
          const epm = Math.round((episodesCount / diff) * 60)
          document.getElementById("episodes-per-minute").textContent = epm
        }
      }, 1000)

      function drawGame(gameState) {
        if (!gameState) return

        // Clear canvas
        ctx.fillStyle = "#2C3E50"
        ctx.fillRect(0, 0, canvas.width, canvas.height)

        // Calculate cell size based on canvas dimensions
        const cellWidth = canvas.width / GRID_WIDTH
        const cellHeight = canvas.height / GRID_HEIGHT

        // Draw wall boxes - positioned at the edges of the canvas
        const normalWallColor = "rgba(120, 120, 120, 0.8)" // Darker grey with higher opacity
        let collidedWallBox = null
        let collidedWallColor = null

        // Determine if there's a wall collision and which box was hit
        if (gameState.failure_reason === "wall" && gameState.collision_flash) {
          const [x, y, opacity] = gameState.collision_flash
          console.log("Wall collision detected:", x, y, opacity)

          // Create a pulsing effect for the collided wall
          const pulseRate = 0.2 // Slower pulse rate
          const pulseOpacity = (Math.sin((Date.now() * pulseRate) / 1000) * 0.2 + 0.8) * opacity // Higher base opacity
          collidedWallColor = `rgba(255, 0, 0, ${pulseOpacity})`

          // Determine which wall box was hit
          if (x <= 0) {
            // Left wall collision
            collidedWallBox = { x: 0, y: Math.floor(y) }
          } else if (x >= GRID_WIDTH - 1) {
            // Right wall collision
            collidedWallBox = { x: GRID_WIDTH - 1, y: Math.floor(y) }
          }

          if (y <= 0) {
            // Top wall collision
            collidedWallBox = { x: Math.floor(x), y: 0 }
          } else if (y >= GRID_HEIGHT - 1) {
            // Bottom wall collision
            collidedWallBox = { x: Math.floor(x), y: GRID_HEIGHT - 1 }
          }
        }

        // First, draw the playable grid - before the walls
        ctx.strokeStyle = "#34495E"
        ctx.lineWidth = 0.5 // Thinner grid lines
        // Draw vertical grid lines (adjust to leave space for walls)
        for (let x = 1; x < GRID_WIDTH; x++) {
          ctx.beginPath()
          ctx.moveTo(x * cellWidth, cellHeight)
          ctx.lineTo(x * cellWidth, canvas.height - cellHeight)
          ctx.stroke()
        }
        // Draw horizontal grid lines (adjust to leave space for walls)
        for (let y = 1; y < GRID_HEIGHT; y++) {
          ctx.beginPath()
          ctx.moveTo(cellWidth, y * cellHeight)
          ctx.lineTo(canvas.width - cellWidth, y * cellHeight)
          ctx.stroke()
        }

        // Draw top wall boxes - positioned at the top edge of the canvas
        for (let x = 0; x < GRID_WIDTH; x++) {
          const isCollided = collidedWallBox && collidedWallBox.x === x && collidedWallBox.y === 0
          ctx.fillStyle = isCollided ? collidedWallColor : normalWallColor

          // Make collided box slightly larger
          const boxSize = isCollided ? 1.2 : 1
          const xPos = x * cellWidth
          const yPos = 0 // Position at the top edge of canvas
          const width = cellWidth * boxSize
          const height = cellHeight * boxSize

          // Draw with adjustment for larger size
          ctx.fillRect(
            xPos - (width - cellWidth) / 2,
            yPos - (height - cellHeight) / 2,
            width,
            height
          )

          // Add border
          ctx.strokeStyle = "rgba(60, 60, 60, 0.9)" // Darker border
          ctx.lineWidth = 1.5 // Thicker border
          ctx.strokeRect(
            xPos - (width - cellWidth) / 2,
            yPos - (height - cellHeight) / 2,
            width,
            height
          )
        }

        // Draw bottom wall boxes - positioned at the bottom edge of the canvas
        for (let x = 0; x < GRID_WIDTH; x++) {
          const isCollided =
            collidedWallBox && collidedWallBox.x === x && collidedWallBox.y === GRID_HEIGHT - 1
          ctx.fillStyle = isCollided ? collidedWallColor : normalWallColor

          // Make collided box slightly larger
          const boxSize = isCollided ? 1.2 : 1
          const xPos = x * cellWidth
          const yPos = canvas.height - cellHeight // Position at the bottom edge, visible
          const width = cellWidth * boxSize
          const height = cellHeight * boxSize

          // Draw with adjustment for larger size
          ctx.fillRect(
            xPos - (width - cellWidth) / 2,
            yPos - (height - cellHeight) / 2,
            width,
            height
          )

          // Add border
          ctx.strokeStyle = "rgba(60, 60, 60, 0.9)" // Darker border
          ctx.lineWidth = 1.5 // Thicker border
          ctx.strokeRect(
            xPos - (width - cellWidth) / 2,
            yPos - (height - cellHeight) / 2,
            width,
            height
          )
        }

        // Draw left wall boxes - positioned at the left edge of the canvas
        for (let y = 0; y < GRID_HEIGHT; y++) {
          const isCollided = collidedWallBox && collidedWallBox.x === 0 && collidedWallBox.y === y
          ctx.fillStyle = isCollided ? collidedWallColor : normalWallColor

          // Make collided box slightly larger
          const boxSize = isCollided ? 1.2 : 1
          const xPos = 0 // Position at the left edge of canvas
          const yPos = y * cellHeight
          const width = cellWidth * boxSize
          const height = cellHeight * boxSize

          // Draw with adjustment for larger size
          ctx.fillRect(
            xPos - (width - cellWidth) / 2,
            yPos - (height - cellHeight) / 2,
            width,
            height
          )

          // Add border
          ctx.strokeStyle = "rgba(60, 60, 60, 0.9)" // Darker border
          ctx.lineWidth = 1.5 // Thicker border
          ctx.strokeRect(
            xPos - (width - cellWidth) / 2,
            yPos - (height - cellHeight) / 2,
            width,
            height
          )
        }

        // Draw right wall boxes - positioned at the right edge of the canvas
        for (let y = 0; y < GRID_HEIGHT; y++) {
          const isCollided =
            collidedWallBox && collidedWallBox.x === GRID_WIDTH - 1 && collidedWallBox.y === y
          ctx.fillStyle = isCollided ? collidedWallColor : normalWallColor

          // Make collided box slightly larger
          const boxSize = isCollided ? 1.2 : 1
          const xPos = canvas.width - cellWidth // Position at the right edge, visible
          const yPos = y * cellHeight
          const width = cellWidth * boxSize
          const height = cellHeight * boxSize

          // Draw with adjustment for larger size
          ctx.fillRect(
            xPos - (width - cellWidth) / 2,
            yPos - (height - cellHeight) / 2,
            width,
            height
          )

          // Add border
          ctx.strokeStyle = "rgba(60, 60, 60, 0.9)" // Darker border
          ctx.lineWidth = 1.5 // Thicker border
          ctx.strokeRect(
            xPos - (width - cellWidth) / 2,
            yPos - (height - cellHeight) / 2,
            width,
            height
          )
        }

        // Add a "pop" animation for the collided box
        if (collidedWallBox && gameState.collision_flash) {
          const [x, y, opacity] = gameState.collision_flash

          // Only show the pop animation when opacity is high enough
          if (opacity > 0.3) {
            // Lower threshold to make it more visible
            let centerX, centerY

            if (collidedWallBox.x === 0) {
              // Left wall
              centerX = cellWidth / 2
              centerY = collidedWallBox.y * cellHeight + cellHeight / 2
            } else if (collidedWallBox.x === GRID_WIDTH - 1) {
              // Right wall
              centerX = canvas.width - cellWidth / 2
              centerY = collidedWallBox.y * cellHeight + cellHeight / 2
            } else if (collidedWallBox.y === 0) {
              // Top wall
              centerX = collidedWallBox.x * cellWidth + cellWidth / 2
              centerY = cellHeight / 2
            } else if (collidedWallBox.y === GRID_HEIGHT - 1) {
              // Bottom wall
              centerX = collidedWallBox.x * cellWidth + cellWidth / 2
              centerY = canvas.height - cellHeight / 2
            }

            // Draw a circular flash
            const radius = Math.max(cellWidth, cellHeight) * 2 * opacity // Larger radius
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius)

            gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity * 0.9})`) // Brighter flash
            gradient.addColorStop(0.5, `rgba(255, 100, 100, ${opacity * 0.7})`) // More visible middle
            gradient.addColorStop(1, `rgba(255, 50, 50, 0)`)

            ctx.fillStyle = gradient
            ctx.beginPath()
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2)
            ctx.fill()

            // Add text label near the collision - larger and more visible
            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`
            ctx.font = "bold 18px Arial" // Larger font
            ctx.textAlign = "center"
            ctx.textBaseline = "middle"

            // Add background for text
            const textWidth = 100
            const textHeight = 24
            ctx.fillStyle = `rgba(0, 0, 0, ${opacity * 0.7})`
            ctx.fillRect(centerX - textWidth / 2, centerY - textHeight / 2, textWidth, textHeight)

            // Draw text
            ctx.fillStyle = `rgba(255, 50, 50, ${opacity})`
            ctx.fillText("WALL HIT", centerX, centerY)

            // Add pulsing border around the entire game area when collision occurs
            const borderPulse = (Math.sin((Date.now() * 0.3) / 1000) * 0.3 + 0.7) * opacity
            ctx.strokeStyle = `rgba(255, 0, 0, ${borderPulse})`
            ctx.lineWidth = 3
            ctx.strokeRect(0, 0, canvas.width, canvas.height)
          }
        }

        // Draw snake
        gameState.snake.forEach(([x, y], index) => {
          // Head is slightly different color
          if (index === 0) {
            ctx.fillStyle = "#27ae60"
          } else {
            ctx.fillStyle = "#2ECC71"
          }
          ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth - 1, cellHeight - 1)
        })

        // Draw apple
        ctx.fillStyle = "#E74C3C"
        ctx.fillRect(
          gameState.apple[0] * cellWidth,
          gameState.apple[1] * cellHeight,
          cellWidth - 1,
          cellHeight - 1
        )

        // Draw collision flash if it exists (keep this for non-wall collisions)
        if (
          gameState.collision_flash &&
          Array.isArray(gameState.collision_flash) &&
          gameState.collision_flash.length === 3 &&
          gameState.failure_reason !== "wall" // Only show for non-wall collisions
        ) {
          try {
            const [x, y, opacity] = gameState.collision_flash
            // Create a radial gradient for the flash effect
            const radius = Math.max(cellWidth, cellHeight) * 2
            const centerX = x * cellWidth + cellWidth / 2
            const centerY = y * cellHeight + cellHeight / 2
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius)

            // Set gradient colors with opacity
            gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`)
            gradient.addColorStop(0.5, `rgba(255, 200, 100, ${opacity * 0.7})`)
            gradient.addColorStop(1, `rgba(255, 100, 50, ${opacity * 0.3})`)

            // Draw the flash
            ctx.fillStyle = gradient
            ctx.beginPath()
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2)
            ctx.fill()
          } catch (error) {
            console.error("Error drawing collision flash:", error)
          }
        }
      }

      socket.on("metrics_update", function (data) {
        try {
          const metrics = JSON.parse(data)
          console.log("Received metrics update:", metrics)

          // Update stats
          document.getElementById("current-score").textContent = metrics.current_score
          document.getElementById("avg-score").textContent = metrics.avg_score.toFixed(2)
          document.getElementById("max-score").textContent = metrics.max_score
          document.getElementById("episodes").textContent = metrics.episodes
          document.getElementById("success-rate").textContent =
            metrics.success_rate.toFixed(1) + "%"
          document.getElementById("avg-reward").textContent = metrics.avg_reward.toFixed(2)
          document.getElementById("epsilon").textContent = metrics.epsilon.toFixed(3)
          document.getElementById("learning-rate").textContent = metrics.learning_rate.toFixed(6)
          document.getElementById("steps-per-apple").textContent = metrics.avg_steps_per_apple
            ? metrics.avg_steps_per_apple.toFixed(1)
            : "0.0"
          document.getElementById("moving-avg").textContent = metrics.moving_avg.toFixed(2)

          // Update failure stats if provided
          if (metrics.failure_reason) {
            failureStats.total++
            if (metrics.failure_reason === "wall") {
              failureStats.wallCollision++
              // Update the wall collision counter
              document.getElementById("wall-collisions").textContent = failureStats.wallCollision
            } else if (metrics.failure_reason === "self") {
              failureStats.selfCollision++
            } else if (metrics.failure_reason === "timeout") {
              failureStats.timeout++
            }

            // Update failure stats display
            updateFailureStats()

            // Record episode number for failure tracking
            if (
              episodesForFailures.length === 0 ||
              episodesForFailures[episodesForFailures.length - 1] !== metrics.episodes
            ) {
              episodesForFailures.push(metrics.episodes)

              // Calculate percentages for this point in time
              const total =
                failureStats.wallCollision + failureStats.selfCollision + failureStats.timeout
              const wallPercent = total > 0 ? (failureStats.wallCollision / total) * 100 : 0
              const selfPercent = total > 0 ? (failureStats.selfCollision / total) * 100 : 0
              const timeoutPercent = total > 0 ? (failureStats.timeout / total) * 100 : 0

              // Add to history arrays
              wallCollisionHistory.push(wallPercent)
              selfCollisionHistory.push(selfPercent)
              timeoutHistory.push(timeoutPercent)
            }
          }

          // Update charts data
          if (metrics.episodes > 0) {
            // Only add new data points if they don't already exist
            if (!episodes.includes(metrics.episodes)) {
              scores.push(metrics.current_score)
              episodes.push(metrics.episodes)
              rewards.push(metrics.avg_reward)
              learningRates.push(metrics.learning_rate)

              // Update charts with new data
              updateCharts()
            }
          }
        } catch (error) {
          console.error("Error processing metrics update:", error)
        }
      })

      function updateFailureStats() {
        if (failureStats.total > 0) {
          const wallPercent = ((failureStats.wallCollision / failureStats.total) * 100).toFixed(1)
          const selfPercent = ((failureStats.selfCollision / failureStats.total) * 100).toFixed(1)
          const timeoutPercent = ((failureStats.timeout / failureStats.total) * 100).toFixed(1)

          document.getElementById("wall-failure-bar").style.width = wallPercent + "%"
          document.getElementById("self-failure-bar").style.width = selfPercent + "%"
          document.getElementById("timeout-failure-bar").style.width = timeoutPercent + "%"
        }
      }

      function updateCharts() {
        // Score chart
        const scoreTrace = {
          x: episodes,
          y: scores,
          type: "scatter",
          mode: "lines",
          name: "Score",
          line: { color: "#2ECC71" },
        }

        const scoreLayout = {
          title: "Training Progress",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: { title: "Score", gridcolor: "#455565" },
        }

        // Reward chart
        const rewardTrace = {
          x: episodes,
          y: rewards,
          type: "scatter",
          mode: "lines",
          name: "Avg Reward",
          line: { color: "#F39C12" },
        }

        const rewardLayout = {
          title: "Average Reward",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: { title: "Reward", gridcolor: "#455565" },
        }

        // Learning rate chart
        const learningRateTrace = {
          x: episodes,
          y: learningRates,
          type: "scatter",
          mode: "lines",
          name: "Learning Rate",
          line: { color: "#3498DB" },
        }

        const learningRateLayout = {
          title: "Learning Rate Adaptation",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: {
            title: "Learning Rate",
            gridcolor: "#455565",
            type: "log",
          },
        }

        // Failure reasons chart
        const wallCollisionTrace = {
          x: episodesForFailures,
          y: wallCollisionHistory,
          type: "scatter",
          mode: "lines",
          name: "Wall Collision",
          line: { color: "#E74C3C" },
        }

        const selfCollisionTrace = {
          x: episodesForFailures,
          y: selfCollisionHistory,
          type: "scatter",
          mode: "lines",
          name: "Self Collision",
          line: { color: "#F39C12" },
        }

        const timeoutTrace = {
          x: episodesForFailures,
          y: timeoutHistory,
          type: "scatter",
          mode: "lines",
          name: "Timeout",
          line: { color: "#3498DB" },
        }

        const failureReasonsLayout = {
          title: "Failure Reasons Over Time",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: {
            title: "Percentage",
            gridcolor: "#455565",
            tickformat: ".0%",
            range: [0, 100],
          },
          legend: {
            orientation: "h",
            y: -0.2,
          },
        }

        Plotly.newPlot("score-chart", [scoreTrace], scoreLayout)
        Plotly.newPlot("reward-chart", [rewardTrace], rewardLayout)
        Plotly.newPlot("learning-rate-chart", [learningRateTrace], learningRateLayout)
        Plotly.newPlot(
          "failure-reasons-chart",
          [wallCollisionTrace, selfCollisionTrace, timeoutTrace],
          failureReasonsLayout
        )
      }

      socket.on("game_state_update", function (data) {
        try {
          const gameState = JSON.parse(data)

          // Check for new wall collision
          if (
            gameState.failure_reason === "wall" &&
            (!lastGameState || lastGameState.failure_reason !== "wall")
          ) {
            wallCollisionCount++
            // Update wall collision counter in the UI
            document.getElementById("wall-collisions").textContent =
              failureStats.wallCollision || wallCollisionCount
          }

          lastGameState = gameState
          drawGame(gameState)
        } catch (error) {
          console.error("Error processing game state:", error)
        }
      })

      socket.on("training_reset", function () {
        console.log("Training reset event received")

        // Clear the chart data
        scores = []
        episodes = []
        rewards = []
        learningRates = []
        wallCollisionHistory = []
        selfCollisionHistory = []
        timeoutHistory = []
        episodesForFailures = []

        // Reset failure stats
        failureStats = {
          wallCollision: 0,
          selfCollision: 0,
          timeout: 0,
          total: 0,
        }

        // Reset wall collision counter
        wallCollisionCount = 0
        document.getElementById("wall-collisions").textContent = "0"
        document.getElementById("self-collisions").textContent = "0"
        document.getElementById("timeouts").textContent = "0"
        document.getElementById("self-collision-percent").textContent = "0%"
        document.getElementById("recent-self-collision-rate").textContent = "0%"

        // Update failure stats display
        document.getElementById("wall-failure-bar").style.width = "0%"
        document.getElementById("self-failure-bar").style.width = "0%"
        document.getElementById("timeout-failure-bar").style.width = "0%"

        // Redraw the charts with empty data
        const emptyTrace = {
          x: [],
          y: [],
          type: "scatter",
          mode: "lines",
        }

        const scoreLayout = {
          title: "Training Progress",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: { title: "Score", gridcolor: "#455565" },
        }

        const rewardLayout = {
          title: "Average Reward",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: { title: "Reward", gridcolor: "#455565" },
        }

        const learningRateLayout = {
          title: "Learning Rate Adaptation",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: {
            title: "Learning Rate",
            gridcolor: "#455565",
            type: "log",
          },
        }

        Plotly.newPlot("score-chart", [emptyTrace], scoreLayout)
        Plotly.newPlot("reward-chart", [emptyTrace], rewardLayout)
        Plotly.newPlot("learning-rate-chart", [emptyTrace], learningRateLayout)
        Plotly.newPlot("failure-reasons-chart", [emptyTrace], {
          title: "Failure Reasons Over Time",
          paper_bgcolor: "#34495E",
          plot_bgcolor: "#34495E",
          font: { color: "#ECF0F1" },
          margin: { l: 50, r: 30, t: 40, b: 40 },
          xaxis: { title: "Episode", gridcolor: "#455565" },
          yaxis: {
            title: "Percentage",
            gridcolor: "#455565",
            tickformat: ".0%",
            range: [0, 100],
          },
        })

        // Clear the stats display
        document.getElementById("current-score").textContent = "0"
        document.getElementById("avg-score").textContent = "0.0"
        document.getElementById("max-score").textContent = "0"
        document.getElementById("episodes").textContent = "0"
        document.getElementById("success-rate").textContent = "0.0%"
        document.getElementById("avg-reward").textContent = "0.0"
        document.getElementById("epsilon").textContent = "0.1"
        document.getElementById("learning-rate").textContent = "0.001"
        document.getElementById("steps-per-apple").textContent = "0.0"
        document.getElementById("moving-avg").textContent = "0.0"
        document.getElementById("episodes-per-minute").textContent = "0"

        // Reset timer
        startTime = new Date()

        // Clear any cached game state
        drawGame({ snake: [], apple: [0, 0] })

        console.log("UI reset complete")
      })

      // Handle window resize
      window.addEventListener("resize", function () {
        resizeCanvas()
        updateCharts()
      })

      // Add new socket handler for the new training_stats event
      socket.on("training_stats", function (data) {
        try {
          const stats = JSON.parse(data)
          updateTrainingStats(stats)
        } catch (e) {
          console.error("Error parsing training stats:", e)
        }
      })

      function updateTrainingStats(stats) {
        // Update basic training stats
        document.getElementById("episodes").textContent = stats.total_episodes
        document.getElementById("max-score").textContent = stats.max_score
        document.getElementById("avg-score").textContent = stats.avg_score.toFixed(2)
        document.getElementById("success-rate").textContent = stats.success_rate.toFixed(2) + "%"
        document.getElementById("epsilon").textContent = stats.current_epsilon.toFixed(5)
        document.getElementById("learning-rate").textContent =
          stats.current_learning_rate.toFixed(5)

        // Add current score if available (we don't have this in the new format)
        if (stats.current_score !== undefined) {
          document.getElementById("current-score").textContent = stats.current_score
        }

        // Update additional metrics from the old format if available
        if (stats.avg_reward !== undefined) {
          document.getElementById("avg-reward").textContent = stats.avg_reward.toFixed(2)
        }

        if (stats.moving_avg !== undefined) {
          document.getElementById("moving-avg").textContent = stats.moving_avg.toFixed(2)
        }

        // Update self-collision specific stats
        const selfCollisions = stats.failure_counts.self || 0
        document.getElementById("self-collisions").textContent = selfCollisions
        document.getElementById("wall-collisions").textContent = stats.failure_counts.wall || 0
        document.getElementById("timeouts").textContent = stats.failure_counts.timeout || 0

        const selfCollisionPercent = stats.failure_percentages.self || 0
        document.getElementById("self-collision-percent").textContent =
          selfCollisionPercent.toFixed(2) + "%"

        document.getElementById("recent-self-collision-rate").textContent =
          stats.recent_self_collision_rate.toFixed(2) + "%"

        // Update failure breakdown bars
        updateFailureBar("wall-failure-bar", stats.failure_percentages.wall || 0, "Wall")
        updateFailureBar("self-failure-bar", stats.failure_percentages.self || 0, "Self")
        updateFailureBar("timeout-failure-bar", stats.failure_percentages.timeout || 0, "Timeout")

        // Update chart data arrays with historical data
        if (stats.episode_numbers && stats.episode_numbers.length > 0) {
          // Use the provided episode numbers
          episodes = stats.episode_numbers

          // Update scores array if we have moving average scores
          if (stats.moving_avg_scores && stats.moving_avg_scores.length > 0) {
            scores = stats.moving_avg_scores
          }

          // Use historical reward data if available
          if (stats.rewards_history && stats.rewards_history.length > 0) {
            rewards = stats.rewards_history
          } else if (stats.avg_score) {
            // Fallback to placeholder data
            rewards = new Array(episodes.length).fill(stats.avg_score)
          }

          // Use historical learning rate data if available
          if (stats.learning_rates_history && stats.learning_rates_history.length > 0) {
            learningRates = stats.learning_rates_history
          } else {
            // Fallback to placeholder data
            learningRates = new Array(episodes.length).fill(stats.current_learning_rate)
          }

          // Update failure data for failure reasons chart
          if (
            stats.failure_episodes &&
            stats.failure_episodes.length > 0 &&
            stats.wall_pct_history &&
            stats.self_pct_history &&
            stats.timeout_pct_history
          ) {
            episodesForFailures = stats.failure_episodes
            wallCollisionHistory = stats.wall_pct_history
            selfCollisionHistory = stats.self_pct_history
            timeoutHistory = stats.timeout_pct_history
          } else {
            // Fallback to placeholder data
            episodesForFailures = episodes
            const wallPercent = stats.failure_percentages.wall || 0
            const selfPercent = stats.failure_percentages.self || 0
            const timeoutPercent = stats.failure_percentages.timeout || 0

            wallCollisionHistory = new Array(episodes.length).fill(wallPercent)
            selfCollisionHistory = new Array(episodes.length).fill(selfPercent)
            timeoutHistory = new Array(episodes.length).fill(timeoutPercent)
          }

          // Update charts with the new data
          updateCharts()
        }
      }

      function updateFailureBar(id, percentage, label) {
        const bar = document.getElementById(id)
        if (bar) {
          bar.style.width = percentage + "%"
          bar.setAttribute("aria-valuenow", percentage)
          bar.textContent = label + " (" + percentage.toFixed(1) + "%)"
        }
      }
    </script>
  </body>
</html>
